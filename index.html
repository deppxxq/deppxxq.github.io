<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Личный зачёт — Top 3</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&display=swap" rel="stylesheet">

<style>
  :root{
    /* === СИНИЙ + БЕЛЫЙ === */
    --bgA:#071a33;
    --bgB:#f4f8ff;
    --accent:#1f66ff;
    --accentSoft:#7fb2ff;

    --panel: rgba(255,255,255,.78);
    --panel2: rgba(245,248,255,.90);
    --stroke: rgba(8,40,110,.14);

    --text:#0b1c33;
    --muted:#4a5f85;

    /* медали */
    --gold1:#b8860b; --gold2:#ffd700;
    --silver1:#8b8b8b; --silver2:#d7d7d7;
    --bronze1:#7a3d12; --bronze2:#cd7f32;
  }

  *{ box-sizing:border-box; }

  html, body{
    margin:0; padding:0;
    width:100%; height:100%;
    overflow:hidden;
    font-family: Rajdhani, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: var(--text);
    background:
      radial-gradient(1200px 800px at 75% 10%, rgba(127,178,255,.45), transparent 55%),
      radial-gradient(1200px 800px at 15% 85%, rgba(31,102,255,.28), transparent 60%),
      linear-gradient(135deg, var(--bgA), var(--bgB));
  }

  body::before{
    content:"";
    position:fixed; inset:0;
    background:
      repeating-linear-gradient(45deg, rgba(255,255,255,.22) 0 2px, rgba(0,0,0,0) 2px 14px),
      repeating-linear-gradient(-45deg, rgba(255,255,255,.14) 0 2px, rgba(0,0,0,0) 2px 18px);
    opacity:.14;
    pointer-events:none;
  }

  .app{
    width:100vw;
    height:100svh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding: 2.8vh 3.5vw;
  }

  .board{
    width: min(1500px, 96vw);
    height: min(920px, 94svh);
    border-radius: 18px;
    background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(244,248,255,.86));
    border: 1px solid rgba(8,40,110,.14);
    box-shadow: 0 18px 60px rgba(8,40,110,.22);
    overflow:hidden;
    position:relative;
    backdrop-filter: blur(6px);
  }

  .board::after{
    content:"";
    position:absolute; inset:0;
    background:
      linear-gradient(115deg, transparent 0 60%, rgba(31,102,255,.12) 60% 64%, transparent 64% 100%),
      linear-gradient(115deg, transparent 0 74%, rgba(31,102,255,.08) 74% 76%, transparent 76% 100%);
    pointer-events:none;
  }

  .wm{
    position:absolute;
    left: 4%;
    bottom: 2%;
    font-size: clamp(70px, 11vw, 170px);
    font-weight: 700;
    letter-spacing: .08em;
    color: rgba(31,102,255,.07);
    user-select:none;
    pointer-events:none;
    transform: skewX(-10deg);
    z-index:0;
  }

  .header{
    position:relative;
    z-index:2;
    padding: 22px 24px 14px;
    border-bottom: 1px solid rgba(8,40,110,.12);
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap: 16px;
  }

  .titleWrap{ display:flex; flex-direction:column; gap:6px; min-width:0; }

  .title{
    font-size: clamp(34px, 4.9vw, 72px);
    font-weight: 700;
    letter-spacing: .10em;
    text-transform: uppercase;
    line-height: 1;
    color: var(--accent);
    text-shadow: 0 10px 40px rgba(31,102,255,.12);
  }

  .sub{
    display:flex;
    align-items:center;
    gap:12px;
    color: var(--muted);
    font-weight: 700;
    letter-spacing:.16em;
    text-transform: uppercase;
    font-size: clamp(14px, 1.5vw, 20px);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .sub .dot{
    width:10px; height:10px; border-radius:50%;
    background: var(--accent);
    box-shadow: 0 0 18px rgba(31,102,255,.35);
  }

  .stage{
    display:flex;
    align-items:center;
    gap: 12px;
    padding: 10px 14px;
    border-radius: 12px;
    background: rgba(255,255,255,.65);
    border: 1px solid rgba(8,40,110,.14);
    box-shadow: inset 0 0 18px rgba(255,255,255,.45);
    white-space:nowrap;
  }
  .stage .label{
    font-weight: 700;
    letter-spacing:.18em;
    text-transform: uppercase;
    color: rgba(11,28,51,.85);
    font-size: clamp(12px, 1.2vw, 16px);
  }
  .stage .val{
    font-weight: 700;
    letter-spacing:.12em;
    text-transform: uppercase;
    color: rgba(11,28,51,.70);
    font-size: clamp(12px, 1.2vw, 16px);
  }

  .content{
    position:relative;
    z-index:2;
    height: calc(100% - 92px);
    padding: 18px 24px 24px;
    display:flex;
    flex-direction:column;
    gap: 16px;
  }

  .checkline{
    height: 10px;
    border-radius: 999px;
    background:
      linear-gradient(90deg, rgba(31,102,255,.75), rgba(31,102,255,0)),
      repeating-linear-gradient(90deg, rgba(8,40,110,.22) 0 10px, rgba(0,0,0,0) 10px 20px);
    opacity:.9;
    border: 1px solid rgba(8,40,110,.10);
  }

  .rows{
    flex:1;
    display:flex;
    flex-direction:column;
    justify-content:center;
    gap: 14px;
    position:relative;
  }

  .row{
    height: clamp(92px, 14vh, 150px);
    display:grid;
    grid-template-columns: 92px 1fr 160px;
    gap: 12px;
    align-items:stretch;
    will-change: transform;
  }

  /* небольшой интерактив на hover */
  .rowHover{
    filter: drop-shadow(0 10px 18px rgba(8,40,110,.18));
  }
  .cardHover{
    border-color: rgba(31,102,255,.35) !important;
  }

  .placeBox{
    border-radius: 14px;
    background: rgba(31,102,255,.10);
    border: 1px solid rgba(31,102,255,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size: clamp(28px, 3.2vw, 52px);
    font-weight: 700;
    letter-spacing: .05em;
    color: var(--accent);
    position:relative;
    overflow:hidden;
  }
  .placeBox::after{
    content:"";
    position:absolute; inset:0;
    background: linear-gradient(135deg, rgba(255,255,255,.35), transparent 55%);
    pointer-events:none;
    opacity:.55;
  }

  .card{
    border-radius: 14px;
    background: var(--panel2);
    border: 1px solid rgba(8,40,110,.14);
    position:relative;
    overflow:hidden;
    display:grid;
    grid-template-columns: 86px 1fr 90px;
    gap: 12px;
    align-items:center;
    padding: 12px 14px;
  }

  .card::after{
    content:"";
    position:absolute; inset:0;
    background: linear-gradient(115deg, transparent 0 66%, rgba(31,102,255,.08) 66% 68%, transparent 68% 100%);
    pointer-events:none;
  }

  .card::before{
    content:"";
    position:absolute;
    inset:-90px -220px;
    background: radial-gradient(circle at 30% 50%, rgba(31,102,255,.10), transparent 60%);
    animation: sweep 4.2s ease-in-out infinite;
    opacity:.9;
    pointer-events:none;
  }
  @keyframes sweep{
    0%{ transform: translateX(-45%) rotate(6deg); }
    50%{ transform: translateX(10%) rotate(6deg); }
    100%{ transform: translateX(-45%) rotate(6deg); }
  }

  .avatar{
    width: 74px; height: 74px;
    border-radius: 12px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight: 700;
    font-size: 26px;
    color: white;
    box-shadow: inset 0 0 18px rgba(255,255,255,.25);
    user-select:none;
    overflow:hidden;
  }

  .nameBlock{
    min-width:0;
    display:flex;
    flex-direction:column;
    gap: 8px;
  }

  .name{
    font-size: clamp(22px, 3.0vw, 48px);
    font-weight: 700;
    letter-spacing: .06em;
    text-transform: uppercase;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    line-height:1;
    color: var(--text);
  }

  .meta{
    display:flex;
    align-items:center;
    gap: 10px;
    color: var(--muted);
    font-weight: 700;
    letter-spacing: .18em;
    text-transform: uppercase;
    font-size: clamp(12px, 1.15vw, 16px);
  }
  .meta .bar{
    width: 46px;
    height: 3px;
    border-radius: 999px;
    background: rgba(31,102,255,.55);
  }

  /* SVG-флаг */
  .flag{
    width: 78px;
    height: 44px;
    border-radius: 10px;
    border: 1px solid rgba(8,40,110,.14);
    background: rgba(31,102,255,.06);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    user-select:none;
  }
  .flag svg{ width:100%; height:100%; display:block; }
  .flag.na{
    font-weight:700;
    letter-spacing:.14em;
    color: rgba(11,28,51,.55);
    background: rgba(8,40,110,.06);
  }

  .points{
    border-radius: 14px;
    display:flex;
    flex-direction:column;
    align-items:flex-end;
    justify-content:center;
    padding: 10px 14px;
    color: rgba(0,0,0,.92);
    box-shadow: inset 0 0 18px rgba(255,255,255,.30);
    user-select:none;
    position:relative;
    overflow:hidden;
  }
  .points::after{
    content:"";
    position:absolute; inset:0;
    background: linear-gradient(135deg, rgba(255,255,255,.35), transparent 55%);
    pointer-events:none;
    opacity:.55;
  }
  .points .label{
    font-weight: 700;
    letter-spacing: .22em;
    text-transform: uppercase;
    font-size: clamp(11px, 1.05vw, 15px);
    opacity:.90;
  }
  .points .val{
    font-size: clamp(30px, 3.8vw, 72px);
    font-weight: 700;
    line-height:.95;
    letter-spacing: .06em;
  }

  .gold  .avatar, .gold  .points{ background: linear-gradient(90deg, var(--gold1), var(--gold2)); }
  .silver .avatar, .silver .points{ background: linear-gradient(90deg, var(--silver1), var(--silver2)); }
  .bronze .avatar, .bronze .points{ background: linear-gradient(90deg, var(--bronze1), var(--bronze2)); }

  .gold  .card{ border-color: rgba(255,215,0,.18); }
  .silver .card{ border-color: rgba(140,140,140,.18); }
  .bronze .card{ border-color: rgba(205,127,50,.18); }

  .fade-in{ animation: fadeIn .28s ease; }
  @keyframes fadeIn{
    from{ opacity:0; transform: translateY(12px); }
    to{ opacity:1; transform: translateY(0); }
  }

  .bump{ animation: bump .38s ease; }
  @keyframes bump{
    0%{ transform: scale(1); }
    45%{ transform: scale(1.06); }
    100%{ transform: scale(1); }
  }

  .flip{
    transition: transform 520ms cubic-bezier(.2,.9,.2,1);
  }

  /* ===== Tooltip (детали) ===== */
  .tooltip{
    position:absolute;
    z-index:50;
    min-width: 360px;
    max-width: min(640px, 92vw);
    border-radius: 14px;
    background: rgba(245,248,255,.96);
    border: 1px solid rgba(8,40,110,.18);
    box-shadow: 0 18px 60px rgba(8,40,110,.28);
    overflow:hidden;
    pointer-events:none; /* чтобы не “дергалось” от мыши */
    transform: translateY(8px);
    opacity: 0;
    transition: opacity .12s ease, transform .12s ease;
    backdrop-filter: blur(6px);
  }
  .tooltip.show{
    opacity: 1;
    transform: translateY(0);
  }
  .tt-head{
    padding: 12px 14px;
    background: linear-gradient(90deg, rgba(31,102,255,.14), rgba(31,102,255,0));
    border-bottom: 1px solid rgba(8,40,110,.12);
    display:flex;
    justify-content:space-between;
    gap: 12px;
    align-items:baseline;
  }
  .tt-title{
    font-weight: 700;
    letter-spacing: .08em;
    text-transform: uppercase;
    color: rgba(11,28,51,.92);
    font-size: 18px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .tt-cars{
    font-weight: 700;
    color: rgba(11,28,51,.70);
    letter-spacing:.10em;
    text-transform: uppercase;
    font-size: 12px;
    white-space:nowrap;
  }
  .tt-body{
    padding: 12px 14px 14px;
  }
  .tt-grid{
    display:grid;
    grid-template-columns: 1fr auto;
    gap: 8px 12px;
    align-items:center;
  }
  .tt-k{
    color: rgba(11,28,51,.74);
    font-weight: 700;
    letter-spacing:.08em;
    text-transform: uppercase;
    font-size: 12px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  .tt-v{
    color: rgba(11,28,51,.92);
    font-weight: 700;
    font-size: 14px;
    text-align:right;
    white-space:nowrap;
  }
  .tt-empty{
    color: rgba(11,28,51,.60);
    font-weight: 700;
    letter-spacing:.08em;
    text-transform: uppercase;
    font-size: 12px;
  }

  @media (max-width: 760px){
    .row{ grid-template-columns: 70px 1fr 130px; }
    .card{ grid-template-columns: 72px 1fr 70px; }
    .avatar{ width: 62px; height: 62px; border-radius: 10px; }
    .flag{ width: 64px; height: 40px; }
    .tooltip{ min-width: min(380px, 92vw); }
  }
</style>
</head>

<body>
<div class="app">
  <div class="board" id="board">
    <div class="wm">STANDINGS</div>

    <div class="header">
      <div class="titleWrap">
        <div class="title">ЛИЧНЫЙ ЗАЧЁТ</div>
        <div class="sub"><span class="dot"></span> Top 3 • Live</div>
      </div>

      <div class="stage">
        <div class="label">Этап:</div>
        <div class="val" id="status">подключение…</div>
      </div>
    </div>

    <div class="content">
      <div class="checkline"></div>
      <div class="rows" id="rows"></div>
    </div>

    <!-- Tooltip для деталей -->
    <div class="tooltip" id="tooltip" aria-hidden="true">
      <div class="tt-head">
        <div class="tt-title" id="ttTitle">—</div>
        <div class="tt-cars" id="ttCars">Машины: —</div>
      </div>
      <div class="tt-body" id="ttBody">
        <div class="tt-empty">Нет данных</div>
      </div>
    </div>
  </div>
</div>

<script>
  // ====== ТВОЙ GOOGLE SHEETS (опубликованный) ======
  const PUB_ID  = "2PACX-1vQvwffbzZpdoLI4y1BoWfRvpeE7l4UYSyIoSj9o27T8N7X-7JqI20EYPCv4hUmaZiP81ST1mhkAPiIp";
  const GID_TOP3     = "748230739";
  const GID_DETAILS  = "986522000"; // детали: результаты гонок + машины
  const POLL_MS = 5000;
  // ================================================

  const BASE_CSV_TOP3   = `https://docs.google.com/spreadsheets/d/e/${PUB_ID}/pub?output=csv&gid=${GID_TOP3}&single=true`;
  const BASE_CSV_DETAIL = `https://docs.google.com/spreadsheets/d/e/${PUB_ID}/pub?output=csv&gid=${GID_DETAILS}&single=true`;

  const boardEl  = document.getElementById("board");
  const rowsEl   = document.getElementById("rows");
  const statusEl = document.getElementById("status");

  const tooltipEl = document.getElementById("tooltip");
  const ttTitleEl = document.getElementById("ttTitle");
  const ttCarsEl  = document.getElementById("ttCars");
  const ttBodyEl  = document.getElementById("ttBody");

  // ---- защита от “отката”
  let inFlight = false;
  let reqSeq = 0;

  // ---- анти-дребезг
  let lastState = null;
  let pendingState = null;
  let pendingHits = 0;
  const STABLE_HITS = 2;

  // ---- детали (вторая вкладка)
  let detailsMap = new Map();      // key: lower(name) -> {cars:Set, fields:[{k,v},...]}
  let detailsHash = "";            // чтобы не перепарсивать одинаковое

  function deepCopy(x){ return JSON.parse(JSON.stringify(x)); }

  function sameState(a, b){
    if (!a || !b || a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++){
      if (a[i].name !== b[i].name || a[i].points !== b[i].points || a[i].pos !== b[i].pos) return false;
    }
    return true;
  }

  // ===== SVG FLAGS =====
  function svgUA(){
    return `
      <svg viewBox="0 0 3 2" xmlns="http://www.w3.org/2000/svg" aria-label="Ukraine">
        <rect width="3" height="1" y="0" fill="#005BBB"/>
        <rect width="3" height="1" y="1" fill="#FFD500"/>
      </svg>
    `;
  }
  function svgRU(){
    return `
      <svg viewBox="0 0 3 2" xmlns="http://www.w3.org/2000/svg" aria-label="Russia">
        <rect width="3" height="0.6667" y="0" fill="#FFFFFF"/>
        <rect width="3" height="0.6667" y="0.6667" fill="#0039A6"/>
        <rect width="3" height="0.6667" y="1.3334" fill="#D52B1E"/>
      </svg>
    `;
  }
  function flagSVGByName(name){
    if (!name) return { html: "—", isNA: true };
    const n = name.toLowerCase();
    if (n.includes("ярик"))    return { html: svgUA(), isNA: false };
    if (n.includes("хаяши"))   return { html: svgUA(), isNA: false };
    if (n.includes("николас")) return { html: svgRU(), isNA: false };
    return { html: "—", isNA: true };
  }

  // CSV парсер (кавычки/запятые)
  function parseCSV(text){
    const rows = [];
    let cur = [], cell = "", inQuotes = false;

    for (let i=0; i<text.length; i++){
      const ch = text[i];
      const next = text[i+1];

      if (ch === '"'){
        if (inQuotes && next === '"'){ cell += '"'; i++; }
        else inQuotes = !inQuotes;
      } else if (ch === ',' && !inQuotes){
        cur.push(cell); cell = "";
      } else if ((ch === '\n' || ch === '\r') && !inQuotes){
        if (ch === '\r' && next === '\n') i++;
        cur.push(cell); rows.push(cur);
        cur = []; cell = "";
      } else {
        cell += ch;
      }
    }
    if (cell.length || cur.length){ cur.push(cell); rows.push(cur); }
    return rows;
  }

  const norm = s => (s || "").trim().toLowerCase();

  // Берём все строки, сортируем по очкам, берём TOP 3
  function extractSortedTop3(csvMatrix){
    if (!csvMatrix.length) return [];

    const header = csvMatrix[0].map(norm);
    const idxName   = header.indexOf("пилот");
    const idxPoints = header.indexOf("очки");

    if (idxName === -1 || idxPoints === -1) {
      throw new Error("Не найдены столбцы: Пилот / Очки");
    }

    const all = csvMatrix.slice(1)
      .filter(r => r && r.length)
      .map(r => ({
        name: String((r[idxName] ?? "")).trim(),
        points: Number(String((r[idxPoints] ?? "")).trim().replace(",", ".")) || 0
      }))
      .filter(r => r.name.length > 0);

    all.sort((a,b) => b.points - a.points);
    return all.slice(0,3).map((r, i) => ({ pos: i+1, ...r }));
  }

  function themeByPos(pos){
    return pos === 1 ? "gold" : (pos === 2 ? "silver" : "bronze");
  }

  function initials(name){
    const parts = (name || "").trim().split(/\s+/).filter(Boolean);
    if (parts.length === 0) return "—";
    if (parts.length === 1) return parts[0].slice(0,2).toUpperCase();
    return (parts[0][0] + parts[parts.length-1][0]).toUpperCase();
  }

  // ===== Детали: разбор вкладки gid=986522000 =====
  // Поддерживает 2 самых частых формата:
  // A) "широкий": Пилот | Машина | Гонка1 | Гонка2 | ...
  // B) "строчный": Пилот | Гонка | Результат | Машина  (может быть много строк на пилота)
  function buildDetailsMap(matrix){
    const map = new Map();
    if (!matrix || matrix.length < 2) return map;

    const headerRaw = matrix[0].map(h => (h || "").trim());
    const header = headerRaw.map(norm);

    // индекс пилота
    let idxPilot = header.indexOf("пилот");
    if (idxPilot === -1) idxPilot = header.indexOf("driver");
    if (idxPilot === -1) idxPilot = 0; // fallback

    // возможные колонки
    let idxCar = header.indexOf("машина");
    if (idxCar === -1) idxCar = header.indexOf("car");
    let idxRace = header.indexOf("гонка");
    if (idxRace === -1) idxRace = header.indexOf("race");
    let idxRes  = header.indexOf("результат");
    if (idxRes === -1) idxRes = header.indexOf("позиция");
    if (idxRes === -1) idxRes = header.indexOf("result");

    const looksRowStyle = (idxRace !== -1 && idxRes !== -1); // формат B

    for (let r=1; r<matrix.length; r++){
      const row = matrix[r] || [];
      const pilot = String(row[idxPilot] ?? "").trim();
      if (!pilot) continue;
      const key = pilot.toLowerCase();

      if (!map.has(key)) map.set(key, { cars: new Set(), fields: [] });
      const item = map.get(key);

      // формат B (много строк)
      if (looksRowStyle){
        const race = String(row[idxRace] ?? "").trim();
        const res  = String(row[idxRes] ?? "").trim();

        // машины могут быть в колонке "машина" или в других — если есть
        if (idxCar !== -1){
          const carCell = String(row[idxCar] ?? "").trim();
          splitCars(carCell).forEach(c => item.cars.add(c));
        }

        if (race || res){
          item.fields.push({ k: race || "Гонка", v: res || "—" });
        } else {
          // если вдруг нет гонки/результата — добираем все пары
          for (let c=0; c<headerRaw.length; c++){
            if (c === idxPilot) continue;
            const v = String(row[c] ?? "").trim();
            if (!v) continue;
            const k = headerRaw[c] || `Колонка ${c+1}`;
            if (norm(k).includes("машина") || norm(k).includes("car")) splitCars(v).forEach(x => item.cars.add(x));
            else item.fields.push({ k, v });
          }
        }

      } else {
        // формат A (одна строка = один пилот с множеством колонок)
        if (idxCar !== -1){
          const carCell = String(row[idxCar] ?? "").trim();
          splitCars(carCell).forEach(c => item.cars.add(c));
        }

        for (let c=0; c<headerRaw.length; c++){
          if (c === idxPilot) continue;

          const kRaw = headerRaw[c] || `Колонка ${c+1}`;
          const kN = norm(kRaw);
          const v = String(row[c] ?? "").trim();
          if (!v) continue;

          // машины могут лежать не только в "машина"
          if (kN.includes("машина") || kN.includes("car")) {
            splitCars(v).forEach(x => item.cars.add(x));
          } else {
            item.fields.push({ k: kRaw, v });
          }
        }
      }
    }

    // лёгкая чистка: оставим максимум 14 строк, чтобы не раздувать tooltip
    for (const [k, v] of map.entries()){
      if (v.fields.length > 14) v.fields = v.fields.slice(0, 14);
    }

    return map;
  }

  function splitCars(text){
    if (!text) return [];
    return text
      .split(/[,;/|]+|\s{2,}/g)
      .map(s => s.trim())
      .filter(Boolean);
  }

  async function fetchDetails(){
    try{
      const url = `${BASE_CSV_DETAIL}&_=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) return;

      const text = await res.text();
      // простой hash — достаточно для “изменилось/нет”
      const h = String(text.length) + ":" + text.slice(0, 64) + ":" + text.slice(-64);
      if (h === detailsHash) return;

      const matrix = parseCSV(text.trim());
      detailsMap = buildDetailsMap(matrix);
      detailsHash = h;
    } catch (e){
      // детали не критичны
      console.warn("Details fetch error:", e);
    }
  }

  // ===== Tooltip =====
  let tooltipPinned = false; // для тача: тап = закрепить

  function renderTooltipForName(name){
    const key = (name || "").toLowerCase();
    const d = detailsMap.get(key);

    ttTitleEl.textContent = name || "—";

    if (!d){
      ttCarsEl.textContent = "Машины: —";
      ttBodyEl.innerHTML = `<div class="tt-empty">Нет данных в листе деталей</div>`;
      return;
    }

    const cars = [...d.cars.values()];
    ttCarsEl.textContent = "Машины: " + (cars.length ? cars.join(", ") : "—");

    if (!d.fields.length){
      ttBodyEl.innerHTML = `<div class="tt-empty">Нет результатов гонок</div>`;
      return;
    }

    const rows = d.fields.map(x => `
      <div class="tt-k">${escapeHTML(String(x.k))}</div>
      <div class="tt-v">${escapeHTML(String(x.v))}</div>
    `).join("");

    ttBodyEl.innerHTML = `<div class="tt-grid">${rows}</div>`;
  }

  function positionTooltipNearRow(rowEl){
    const br = boardEl.getBoundingClientRect();
    const rr = rowEl.getBoundingClientRect();

    // предпочитаем справа от строки, иначе сверху
    const gap = 10;
    const maxW = Math.min(640, br.width - 16);
    tooltipEl.style.maxWidth = maxW + "px";

    // временно “покажем”, чтобы померить размер
    tooltipEl.classList.add("show");
    tooltipEl.style.left = "0px";
    tooltipEl.style.top = "0px";
    const tr = tooltipEl.getBoundingClientRect();

    let left = rr.right - br.left + gap;
    let top  = rr.top - br.top;

    // если не помещается справа — ставим слева от строки
    if (left + tr.width > br.width - 8) {
      left = rr.left - br.left - tr.width - gap;
    }
    // если и слева не влезает — центрируем внутри board
    if (left < 8) left = Math.max(8, (br.width - tr.width) / 2);

    // по вертикали: не вылезаем
    if (top + tr.height > br.height - 8) top = br.height - tr.height - 8;
    if (top < 8) top = 8;

    tooltipEl.style.left = `${Math.round(left)}px`;
    tooltipEl.style.top  = `${Math.round(top)}px`;
  }

  function showTooltip(rowEl, name){
    if (!name || name === "—") return;
    renderTooltipForName(name);
    positionTooltipNearRow(rowEl);
    tooltipEl.setAttribute("aria-hidden", "false");
    tooltipEl.classList.add("show");

    rowEl.classList.add("rowHover");
    const card = rowEl.querySelector(".card");
    if (card) card.classList.add("cardHover");
  }

  function hideTooltip(rowEl){
    if (tooltipPinned) return;
    tooltipEl.classList.remove("show");
    tooltipEl.setAttribute("aria-hidden", "true");

    if (rowEl){
      rowEl.classList.remove("rowHover");
      const card = rowEl.querySelector(".card");
      if (card) card.classList.remove("cardHover");
    }
  }

  function escapeHTML(s){
    return s.replace(/[&<>"']/g, ch => ({
      "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;"
    }[ch]));
  }

  // FLIP helpers
  function snapshotRects(){
    const m = new Map();
    [...rowsEl.children].forEach(el => m.set(el.dataset.key, el.getBoundingClientRect()));
    return m;
  }

  function playFLIP(beforeRects){
    [...rowsEl.children].forEach(el => {
      const key = el.dataset.key;
      const after = el.getBoundingClientRect();
      const before = beforeRects.get(key);
      if (!before) return;

      const dx = before.left - after.left;
      const dy = before.top  - after.top;
      if (!dx && !dy) return;

      el.classList.remove("flip");
      el.style.transform = `translate(${dx}px, ${dy}px)`;
      void el.offsetWidth;
      el.classList.add("flip");
      el.style.transform = "";
    });
  }

  function makeRow(item){
    const el = document.createElement("div");
    el.className = `row ${themeByPos(item.pos)} fade-in`;
    el.dataset.key = item.name || `empty-${item.pos}`;

    const f = flagSVGByName(item.name);

    el.innerHTML = `
      <div class="placeBox">${item.pos}</div>

      <div class="card">
        <div class="avatar">${initials(item.name || "—")}</div>

        <div class="nameBlock">
          <div class="name"></div>
          <div class="meta"><span class="bar"></span><span>Пилот</span></div>
        </div>

        <div class="flag ${f.isNA ? "na" : ""}">${f.html}</div>
      </div>

      <div class="points">
        <div class="label">Очки</div>
        <div class="val"></div>
      </div>
    `;

    el.querySelector(".name").textContent = item.name || "—";
    el.querySelector(".val").textContent = Number.isFinite(item.points) ? item.points : 0;

    // hover/touch events (важно: на создании)
    bindTooltipEvents(el);

    return el;
  }

  function bindTooltipEvents(rowEl){
    const getName = () => (rowEl.querySelector(".name")?.textContent || "").trim();

    rowEl.addEventListener("mouseenter", () => {
      if (tooltipPinned) return;
      showTooltip(rowEl, getName());
    });

    rowEl.addEventListener("mouseleave", () => {
      hideTooltip(rowEl);
    });

    // для клавиатуры
    rowEl.setAttribute("tabindex", "0");
    rowEl.addEventListener("focusin", () => {
      if (tooltipPinned) return;
      showTooltip(rowEl, getName());
    });
    rowEl.addEventListener("focusout", () => {
      hideTooltip(rowEl);
    });

    // для тача: тап = закрепить/снять
    rowEl.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const name = getName();
      if (!name || name === "—") return;

      if (!tooltipPinned){
        tooltipPinned = true;
        showTooltip(rowEl, name);
      } else {
        // если тапнули по другой строке — закрепляем на новой
        tooltipPinned = true;
        showTooltip(rowEl, name);
      }
    }, { passive:false });
  }

  // клик по пустому месту — снять закрепление
  boardEl.addEventListener("mousedown", (e) => {
    if (e.target.closest(".row")) return;
    tooltipPinned = false;
    tooltipEl.classList.remove("show");
    tooltipEl.setAttribute("aria-hidden", "true");
    [...rowsEl.children].forEach(r => {
      r.classList.remove("rowHover");
      const c = r.querySelector(".card");
      if (c) c.classList.remove("cardHover");
    });
  });

  // если меняется размер окна — перепозиционировать tooltip
  window.addEventListener("resize", () => {
    if (!tooltipEl.classList.contains("show")) return;
    const active = [...rowsEl.children].find(r => r.classList.contains("rowHover"));
    if (!active) return;
    positionTooltipNearRow(active);
  });

  function bumpPoints(rowEl){
    const p = rowEl.querySelector(".points");
    p.classList.remove("bump");
    void p.offsetWidth;
    p.classList.add("bump");
  }

  function updateFlag(rowEl, name){
    const f = flagSVGByName(name);
    const flagEl = rowEl.querySelector(".flag");
    flagEl.classList.toggle("na", !!f.isNA);
    flagEl.innerHTML = f.html;
  }

  function renderWithReorder(nextTop3){
    const before = snapshotRects();
    const existing = new Map([...rowsEl.children].map(el => [el.dataset.key, el]));

    const frag = document.createDocumentFragment();

    nextTop3.forEach(item => {
      const key = item.name || `empty-${item.pos}`;
      let el = existing.get(key);

      if (!el){
        el = makeRow(item);
      } else {
        el.querySelector(".placeBox").textContent = item.pos;
        el.classList.remove("gold","silver","bronze");
        el.classList.add(themeByPos(item.pos));

        el.querySelector(".name").textContent = item.name || "—";
        el.querySelector(".avatar").textContent = initials(item.name || "—");
        updateFlag(el, item.name);

        const valEl = el.querySelector(".val");
        const oldPts = Number(valEl.textContent) || 0;
        if (oldPts !== item.points){
          valEl.textContent = item.points;
          bumpPoints(el);
        }
      }

      el.dataset.key = key;
      frag.appendChild(el);
    });

    rowsEl.innerHTML = "";
    rowsEl.appendChild(frag);
    playFLIP(before);
  }

  function applyState(state){
    if (sameState(lastState, state)) return;
    lastState = deepCopy(state);

    statusEl.textContent = "UPDATE";
    renderWithReorder(state);
    setTimeout(() => statusEl.textContent = "LIVE", 350);
  }

  function considerState(next){
    if (sameState(lastState, next)){
      pendingState = null;
      pendingHits = 0;
      statusEl.textContent = "LIVE";
      return;
    }

    if (sameState(pendingState, next)){
      pendingHits++;
    } else {
      pendingState = deepCopy(next);
      pendingHits = 1;
    }

    if (pendingHits >= STABLE_HITS){
      applyState(pendingState);
      pendingState = null;
      pendingHits = 0;
    } else {
      statusEl.textContent = "WAIT";
    }
  }

  async function tickTop3(){
    if (inFlight) return;
    inFlight = true;
    const myReq = ++reqSeq;

    try{
      const url = `${BASE_CSV_TOP3}&_=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      if (myReq !== reqSeq) return;

      const matrix = parseCSV(text.trim());
      let top3 = extractSortedTop3(matrix);
      while (top3.length < 3) top3.push({ pos: top3.length+1, name: "—", points: 0 });

      considerState(top3);
    } catch (e){
      statusEl.textContent = "ERROR";
      console.error(e);
    } finally {
      if (myReq === reqSeq) inFlight = false;
    }
  }

  async function tickAll(){
    // обновляем детали параллельно (не блокирует топ-3)
    fetchDetails();
    tickTop3();
  }

  // старт
  fetchDetails();   // чтобы tooltip сразу имел данные
  tickTop3();
  setInterval(tickAll, POLL_MS);
</script>
</body>
</html>
